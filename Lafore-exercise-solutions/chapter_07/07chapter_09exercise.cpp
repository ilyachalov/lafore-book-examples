// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 07chapter_09exercise.cpp
// написать класс, представляющий очередь

#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT
#include <iostream>
using namespace std;

class queue // класс, реализующий очередь
{
private:
	static const int MAX = 10; // количество элементов в массиве
	                           // (одна константа для всех объектов, статическая)
	int q[MAX];                // очередь в виде массива
	int head;                  // элемент в начале очереди
	int tail;                  // элемент в конце очереди
	
	int length;                // длина очереди (количество элементов в ней)
	                           // (это поле класса по условиям задания не требуется,
	                           // но используем его для того, чтобы обезопасить работу
	                           // с очередью)
public:
	queue()            // конструктор
	{
		// очередь пуста
		head = 0; tail = -1;
		length = 0;
	}
	void put(int var); // поместить в очередь
	int get();         // взять из очереди
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);

	queue q1; // создадим очередь

	q1.put(11);
	q1.put(22);
	wcout << L"1: " << q1.get() << endl;
	wcout << L"2: " << q1.get() << endl;
	q1.put(33);
	q1.put(44);
	q1.put(55);
	q1.put(66);
	wcout << L"3: " << q1.get() << endl;
	wcout << L"4: " << q1.get() << endl;
	wcout << L"5: " << q1.get() << endl;
	wcout << L"6: " << q1.get() << endl;

	return 0;
}

void queue::put(int var) // поместить в очередь
{
	// при переполнении очереди произойдет выход из программы с сообщением
	if (length == MAX)
	{
		wcout << L"Очередь не может содержать больше " << MAX << L" элементов!";
		exit(1);
	}

	// если перед добавлением элемента конец очереди совпадает с концом массива,
	// то перебрасываем конец очереди в начало массива
	if (tail == MAX - 1)
		tail = -1;

	q[++tail] = var; length++;
}

int queue::get()         // взять из очереди
{
	// при попытке взять из пустой очереди произойдет выход из программы с сообщением
	if (length == 0)
	{
		wcout << L"Вы попытались взять из пустой очереди!";
		exit(1);
	}

	int var = q[head++]; length--;

	// если после извлечения элемента из очереди индекс начала очереди вышел
	// за конец массива, перебросим его в начало массива
	if (head == MAX)
		head = 0;

	return var;
}