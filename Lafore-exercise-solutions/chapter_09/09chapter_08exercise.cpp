// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 09chapter_08exercise.cpp
// Имеется класс Pstring, созданный в упражнении 2 этой (9-й) главы, реализующий
// «защищенную строку». Требуется с помощью наследования (то есть нужно создать
// новый класс, производный от Pstring) добавить в программу новую функциональность
// из трех методов, с помощью которых можно выделить часть строки и присвоить ее
// другой строке.

// для использования небезопасной функции wcscpy
#define _CRT_SECURE_NO_WARNINGS

#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT
#include <iostream>
using namespace std;
// #include <string.h> // для функции wcscpy не понадобился

class String // класс, представляющий строку (массив символов)
{
protected:                    // исправлено с private на protected, чтобы эти поля были
	                          // доступны в производном классе

	// enum { SZ = 80 }; // максимальный размер строки (нестандартный синтаксис)
	static const int SZ = 80; // максимальный размер строки
							  // (одна константа для всех объектов, статическая)
	wchar_t str[SZ];          // сама строка
public:
	String() // конструктор без параметров
		{ str[0] = L'\0'; }
	String(const wchar_t s[]) // конструктор с одним параметром
	{
		wcscpy(str, s);
		// wcscpy_s(str, SZ, s); // рекомендуемый более безопасный вариант
	}
	void display() const // показ строки на экране
		{ wcout << str; }
	// преобразование объекта класса String к обычной строке (массив типа wchar_t)
	operator wchar_t* ()
		{ return str; }
};

// класс, представляющий «защищенную» строку (с защитой от переполнения массива символов)
class Pstring : public String
{
public:
	Pstring() : String() // конструктор без параметров
		{ }
	Pstring(const wchar_t s[]) : String(test(s)) // конструктор с одним параметром
		{ }
private:
	// метод проверяет заданную строку на превышение буфера SZ
	// (вызывается из конструктора с одним параметром)
	const wchar_t* test(const wchar_t s[])
	{	
		// если длина полученной для определения нашего объекта строки НЕ позволяет ей поместиться
		// в массив символов нашего объекта,
		if (wcslen(s) >= SZ)
		{
			wchar_t ts[SZ];
			int i;                       // то копируем столько символов, сколько может
			for (i = 0; i < SZ - 1; i++) // поместиться, то есть (SZ - 1) символов,
				ts[i] = s[i];            // во временную строку ts
			ts[i] = L'\0';               // (последнее место в массиве оставляем для
										 // нулевого символа)
			return ts;                   // и отправляем строку ts в конструктор базового класса
		}
		else          // если же проблем нет, передаем заданную строку s
			return s; // в конструктор базового класса без изменений
	}
};

// новый класс, добавляющий три метода, с помощью которых можно выделить часть строки и
// присвоить ее другой строке (производный от класса Pstring из упражнения 2 этой (9-й) главы)
class Pstring2 : public Pstring
{
public:
	Pstring2() : Pstring() // конструктор без параметров
		{ }
	Pstring2(const wchar_t s[]) : Pstring(s) // конструктор с одним параметром
		{ }
	// метод извлекает из заданной строки n символов слева, записывает их в строку,
	// вызвавшую метод, и еще возвращает эти символы в объекте текущего класса
	Pstring2 left(Pstring2 source_str, unsigned int n)
	{
		int i;
		for (i = 0; i < n; i++)
			str[i] = source_str[i];
		str[i] = L'\0';
		return Pstring2(str);
	}
	// метод извлекает из заданной строки n символов, начиная с позиции pos, записывает
	// их в строку, вызвавшую метод, и еще возвращает эти символы в объекте текущего класса
	Pstring2 mid(Pstring2 source_str, unsigned int pos, unsigned int n)
	{
		int j = 0;
		for (int i = pos; i < pos + n; i++)
			str[j++] = source_str[i];
		str[j] = L'\0';
		return Pstring2(str);
	}
	// метод извлекает из заданной строки n символов справа, записывает их в строку,
	// вызвавшую метод, и еще возвращает эти символы в объекте текущего класса
	Pstring2 right(Pstring2 source_str, unsigned int n)
	{
		int j = 0;
		for (int i = wcslen(source_str) - n; i < wcslen(source_str); i++)
			str[j++] = source_str[i];
		str[j] = L'\0';
		return Pstring2(str);
	}
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);

	//////////////////////////////////////////////////////////////////////////////////
	// Программа из упражения 2 этой (9-й) главы (только заменил Pstring на Pstring2)

	Pstring2 s1; // используем конструктор без параметров

	wchar_t xstr[] = L"Ура, товарищи! "; // создаем обычную строку

	s1 = xstr; // неявно используем конструктор с одним параметром

	s1.display(); // показываем строку

	Pstring2 s2 = L"Мы победим!"; // снова используем конструктор с одним параметром

	// используем оператор преобразования типов для преобразования объекта типа String
	// в обычную строку (массив типа wchar_t)
	wcout << static_cast<wchar_t*>(s2);
	wcout << endl;

	Pstring2 s3 = L"Эта строка имеет очень большую длину и мы можем быть уверены, что она не "
	               "уместится в отведенный буфер, что приведет к непредсказуемым последствиям.";
	
	s3.display(); // на экран будет выведено только 79 символов (80-е место занимает символ L'\0')
	wcout << endl;

	//////////////////////////////////////////////////////////////////////////////////
	// Тестирование трех методов, добавленных в этом упражнении

	Pstring2 s4;

	wcout << L"Было:   s1 = "; s1.display(); wcout << endl;
	wcout << L"        s2 = "; s2.display(); wcout << endl;
	wcout << L"        s4 = "; s4.display(); wcout << endl;

	s2.left(s1, 3);
	// или
	s4 = s2.left(s1, 3);

	wcout << L"Стало1: s1 = "; s1.display(); wcout << endl;
	wcout << L"        s2 = "; s2.display(); wcout << endl;
	wcout << L"        s4 = "; s4.display(); wcout << endl;

	s2.mid(s1, 5, 5);
	// или
	s4 = s2.mid(s1, 5, 5);

	wcout << L"Стало2: s1 = "; s1.display(); wcout << endl;
	wcout << L"        s2 = "; s2.display(); wcout << endl;
	wcout << L"        s4 = "; s4.display(); wcout << endl;

	s2.right(s1, 4);
	// или
	s4 = s2.right(s1, 4);

	wcout << L"Стало3: s1 = '"; s1.display(); wcout << L"'" << endl;
	wcout << L"        s2 = '"; s2.display(); wcout << L"'" << endl;
	wcout << L"        s4 = '"; s4.display(); wcout << L"'" << endl;

	return 0;
}