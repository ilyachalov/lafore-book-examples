// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 10chapter_11exercise.cpp
// Продолжим работать над задачей из упражнений 9 и 10 данной (10-й) главы.
// Требуется создать класс, который позволит нам обращаться с 10-ю отдельными
// массивами из упражнения 10 как с одним одномерным массивом. Для этого
// потребуется перегрузить операцию индексации ([]). В main требуется
// протестировать этот класс.

// Я немного расширил задачу. Пользователь может задать количество отдельных
// массивов и количество элементов в них (все отдельные массивы имеют одинаковое
// количество элементов). А так как при этом массив указателей на отдельные массивы
// тоже должен быть динамическим, то под него тоже выделяем память в конструкторе,
// а в деструкторе — освобождаем.

// Задание к упражнению 10 главы 10: ///////////////////////////////////////////
// Требуется переписать упражнение 9 (предыдущее) данной (10-й) главы, используя
// для определения массивов подход с операцией выделения памяти new.
////////////////////////////////////////////////////////////////////////////////

// Задание к упражнению 9 главы 10: ////////////////////////////////////////////
// Имеется задача сохранения 100 целых чисел. Поставлено условие:
// наибольший массив, который можно использовать, имеет размер в 10 элементов.
// 
// Для решения данной задачи предлагается определить 10 массивов типа int,
// каждый размером в 10 элементов. Еще один массив размером в 10 элементов
// должен содержать указатели на первые десять массивов.
// 
// Требуется в main написать программу для тестирования полученной структуры.
////////////////////////////////////////////////////////////////////////////////

#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT
#include <iostream>
using namespace std;

class narrays // класс, представляющий единым массивом n отдельных массивов
{
private:
	const int NUMARRAYS; // количество отдельных массивов
	const int MAXSIZE;   // количество элементов в каждом из отдельных массивов
	int **ap;            // указатель на массив указателей на отдельные массивы типа int
public:
	narrays(int na, int ms) : NUMARRAYS(na), MAXSIZE(ms) // конструктор
	{
		// выделим память под массив указателей на отдельные массивы
		ap = new int*[NUMARRAYS];
		// выделим память под нужное количество отдельных массивов нужного размера
		for (int j = 0; j < NUMARRAYS; j++)
			*(ap + j) = new int[MAXSIZE];
	}
	~narrays() // деструктор
	{
		// освобождаем память, выделенную ранее под отдельные массивы
		for (int j = 0; j < NUMARRAYS; j++)
			delete [] *(ap + j);
		// освобождаем память, выделенную ранее под массив указателей на отдельные массивы
		delete [] ap;
	}
	int& operator[] (int n) // перегрузка операции индексации
	{
		int j = n / MAXSIZE; // номер отдельного массива (целочисленное деление)
		int k = n % MAXSIZE; // индекс элемента в отдельном массиве
		return *(*(ap + j) + k);
	}
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	int numarr;  // количество отдельных массивов
	int sizearr; // количество элементов в каждом из отдельных массивов

	wcout << L"Введите количество отдельных массивов (больше 0): "; wcin >> numarr;
	wcout << L"Введите количество элементов в каждом отдельном массиве (больше 0): "; wcin >> sizearr;
	wcout << endl;

	narrays arr(numarr, sizearr); // массив, объединяющий отдельные массивы в одно целое
	int i;                        // индекс единого массива

	// заполним единый массив тестовыми данными
	for (i = 0; i < numarr * sizearr; i++)
		arr[i] = i * 10;

	// выведем тестовые данные, хранящиеся в едином массиве, на экран
	for (i = 0; i < numarr * sizearr; i++)
		wcout << arr[i] << ((i % sizearr == sizearr - 1) ? L'\n' : L' ');

	return 0;
}