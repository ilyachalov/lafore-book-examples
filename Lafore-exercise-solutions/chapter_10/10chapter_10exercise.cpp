// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 10chapter_10exercise.cpp
// Требуется переписать упражнение 9 (предыдущее) данной (10-й) главы, используя
// для определения массивов подход с операцией выделения памяти new.

// Задание к упражнению 9 главы 10: ////////////////////////////////////////////
// Имеется задача сохранения 100 целых чисел. Поставлено условие:
// наибольший массив, который можно использовать, имеет размер в 10 элементов.
// 
// Для решения данной задачи предлагается определить 10 массивов типа int,
// каждый размером в 10 элементов. Еще один массив размером в 10 элементов
// должен содержать указатели на первые десять массивов.
// 
// Требуется в main написать программу для тестирования полученной структуры.
////////////////////////////////////////////////////////////////////////////////

#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT
#include <iostream>
using namespace std;

const int MAXSIZE = 10,   // количество элементов в массиве
          NUMARRAYS = 10; // количество массивов

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);

	int j, k;           // индексы для обращения к элементам массивов
	int *ap[NUMARRAYS]; // массив указателей на массивы

	// определим нужное количество массивов нужного размера
	for (j = 0; j < NUMARRAYS; j++)
		*(ap + j) = new int[MAXSIZE];

	// заполним массивы тестовыми данными
	for (j = 0; j < NUMARRAYS; j++)
		for (k = 0; k < MAXSIZE; k++)
			*(*(ap + j) + k) = (j * 10 + k) * 10;
			// ap[j][k] = (j * 10 + k) * 10; // так тоже можно

	// выведем тестовые данные, хранящиеся в массивах, на экран
	for (j = 0; j < NUMARRAYS; j++)
		for (k = 0; k < MAXSIZE; k++)
			wcout << *(*(ap + j) + k) << ((k == MAXSIZE - 1) ? L'\n' : L' ');
			// wcout << ap[j][k] << ((k == MAXSIZE - 1) ? L'\n' : L' '); // так тоже можно

	return 0;
}