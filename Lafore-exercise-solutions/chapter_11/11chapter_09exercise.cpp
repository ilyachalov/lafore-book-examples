// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 11chapter_09exercise.cpp
// Дана программа из упражнения 4 главы 10, в которой описан класс linklist
// (представляющий связный список). Требуется перегрузить для этого класса
// оператор присваивания и копирующий конструктор. После этого в main необходимо
// протестировать эти операции.

////// Задание к упражнению 4 главы 10: ////////////////////////////////////////
// Имеется пример 447_linklist.cpp текущей (10-й) главы. Требуется
// добавить в класс linklist (связный список) из этого примера деструктор.
// Этот деструктор должен удалять все элементы списка. В тестовых целях
// при удалении каждого элемента требуется выводить сообщение об этом на экран.
//
// Прямо прописывать вызов деструктора в программе (в main) не требуется, так как
// он будет запущен при уничтожении объекта класса. А объект класса будет в случае
// данной программы автоматически уничтожен при окончании работы программы.
////////////////////////////////////////////////////////////////////////////////

#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT
#include <iostream>
using namespace std;

struct link     // элемент списка
{
	int data;   // данные
	link* next; // указатель на следующий элемент списка
};

class linklist            // класс, представляющий связный список
{
private:
	link* first;          // указатель на первый элемент списка
public:
	linklist()            // конструктор без аргументов
		{ first = NULL; } // первого элемента пока нет
	linklist(linklist&);  // перегруженный копирующий конструктор (прототип)
	~linklist();          // деструктор (прототип)
	void additem(int d);  // добавление элемента списка
	void display();       // вывод на экран данных из всех элементов списка
	linklist& operator= (linklist&); // перегруженный оператор присваивания (прототип)
};

linklist::linklist(linklist& li) // перегруженный копирующий конструктор
{
	first = NULL;                // новый связный список пока пуст

	// от копирующего конструктора требуется выделить память под новый связный список
	// и перекопировать в этот новый связный список элементы списка-аргумента li
	
	link* current = li.first;    // начинаем с первого элемента списка-аргумента
	while (current)              // пока не достигнут конец списка-аргумента
	{
		additem(current->data);  // выделим память под новый элемент нового связного списка
		                         // и запишем в него данные из текущего элемента списка-аргумента
		current = current->next; // перейдем к следующему элементу списка-аргумента
	}

	// Нужно заметить, что в этом цикле мы в списке-аргументе идем от первого элемента
	// к последнему; а в новом связном списке мы идем от последнего к первому (так как
	// добавление элемента происходит в начало списка). В связи с этим в новом связном
	// списке данные будут расположены в обратном порядке по сравнению со списком-аргументом.
	// Однако, в задании к упражнению сказано, что об этом не следует беспокоиться.
}

void linklist::additem(int d) // добавление элемента списка
{
	link* newlink = new link; // выделяем память под новый элемент списка
	newlink->data = d;        // сохраняем в него данные
	newlink->next = first;    // указатель на следующий элемент списка
	                          // теперь будет указывать на элемент, который
	                          // до этого был первым
	first = newlink;          // первым теперь стал только что созданный элемент,
	                          // то есть добавление элементов происходит
	                          // в начало связанного списка
}

void linklist::display() // вывод на экран данных из всех элементов списка
{
	link* current = first;              // начинаем с первого элемента
	while (current)                     // пока указатель на текущий элемент
	{                                   // не равен NULL (что означает конец списка)
		wcout << current->data << L' '; // выводим данные
		current = current->next;        // переходим к следующему элементу
	}
	wcout << endl;
}

// деструктор (реализация)
linklist::~linklist()
{
	link* current = first;     // начинаем с первого элемента
	while (current)            // пока не конец (NULL) списка
	{
		first = current->next; // первым становится предыдущий элемент
		delete current;        // освобождаем память, занятую текущим элементом
		wcout << L"Элемент списка удалён." << endl; // сообщение (в тестовых целях)
		current = first;       // теперь текущий элемент тот, который ранее
		                       // был предыдущим
	}
}

linklist& linklist::operator= (linklist& li) // перегруженный оператор присваивания
{
	// проверка на присваивание самому себе
	if (this == &li) return *this;
	
	// от оператора присваивания требуется удалить старый связный список, затем
	// выделить память под новый связный список и перекопировать в этот новый связный список
	// элементы списка-аргумента li

	// удаление старого связного списка
	link* current = first;     // начинаем с первого элемента
	while (current)            // пока не конец (NULL) списка
	{
		first = current->next; // первым становится предыдущий элемент
		delete current;        // освобождаем память, занятую текущим элементом
		current = first;       // теперь текущий элемент тот, который ранее
							   // был предыдущим
	}

	// выделяем память под новый связный список и перекопируем в этот новый связный список
	// элементы списка-аргумента
	current = li.first;          // начинаем с первого элемента списка-аргумента
	while (current)              // пока не достигнут конец списка-аргумента
	{
		additem(current->data);  // выделим память под новый элемент нового связного списка
								 // и запишем в него данные из текущего элемента списка-аргумента
		current = current->next; // перейдем к следующему элементу списка-аргумента
	}

	// Нужно заметить, что в этом цикле мы в списке-аргументе идем от первого элемента
	// к последнему; а в новом связном списке мы идем от последнего к первому (так как
	// добавление элемента происходит в начало списка). В связи с этим в новом связном
	// списке данные будут расположены в обратном порядке по сравнению со списком-аргументом.
	// Однако, в задании к упражнению сказано, что об этом не следует беспокоиться.

	return *this; // вернуть текущий объект
}

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);

	// Чтобы иметь возможность вручную удалить (освободить занятую им память) связный
	// список, мы создадим (выделим под него память) один из списков с помощью оператора new;
	// остальные списки мы создадим обычным путем

	linklist* list1 = new linklist; // создаем связный список

	list1->additem(25); // добавляем четыре элемента в список
	list1->additem(36);
	list1->additem(49);
	list1->additem(64);

	// выведем список на экран
	wcout << L"list1 = "; list1->display();

	linklist list2(*list1); // тестируем перегруженный копирующий конструктор

	linklist list3;
	list3 = *list1;         // тестируем перегруженный оператор присваивания

	// удалим первоначальный список
	delete list1;

	// выводим тестовые списки на экран
	wcout << L"list2 = "; list2.display();
	wcout << L"list3 = "; list3.display();

	// здесь программа завершает свою работу, поэтому автоматически будет
	// выполнено уничтожение объектов list2, list3 класса linklist, при этом будут
	// автоматически запущены деструкторы этих объектов

	return 0;
}