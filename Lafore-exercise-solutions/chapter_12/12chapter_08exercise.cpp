// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 12chapter_08exercise.cpp
// Имеется класс linklist (связный список) из примера 447_linklist.cpp главы 10.
// Требуется написать в main программу, которая дает пользователю 4 возможности:
// 1) добавить элемент в список в памяти (при этом пользователь вводит данные,
// которые будут храниться в элементе списка; в нашем случае — некое целое число);
// 2) вывести на экран элементы списка, находящегося в памяти; 3) записать данные
// всех элементов списка в файл на диске; 4) извлечь данные из файла, создать
// в памяти связный список и записать в него данные из файла.

#include <io.h>      // для функции _setmode
#include <fcntl.h>   // для константы _O_U16TEXT
#include <fstream>   // для файлового ввода/вывода
#include <iostream>
using namespace std;

struct link     // элемент списка
{
	int data;   // данные
	link* next; // указатель на следующий элемент списка
};

class linklist            // класс, представляющий связный список
{
private:
	link* first;          // указатель на первый элемент списка
public:
	linklist()            // конструктор без аргументов
		{ first = NULL; } // первого элемента пока нет
	void additem(int d);  // добавление элемента списка
	void display();       // вывод на экран данных из всех элементов списка
	void diskOut();       // записать данные элементов списка в файл
	void diskIn();        // прочитать данные из файла и записать их в список
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	linklist li; // связный список
	wchar_t ch;  // символ для выбора пользователя

	while (true)
	{
		wcout << L"'д' — добавить элемент в список в памяти"
			L"\n'в' — вывести на экран данные элементов списка в памяти"
			L"\n'з' — записать данные элементов списка в файл"
			L"\n'п' — прочитать данные из файла и записать их в список в памяти"
			L"\n'к' — конец (выход из программы)"
			L"\nВаш выбор: ";
		wcin >> ch;
		switch (ch)
		{
		case L'д':          // добавить элемент в список в памяти
			wcout << L"Введите данные для элемента списка (целое число): ";
			int data; wcin >> data;
			li.additem(data); break;
		case L'в':          // вывести на экран данные элементов списка в памяти
			li.display(); break;
		case L'з':          // записать данные элементов списка в файл
			li.diskOut(); break;
		case L'п':          // прочитать данные из файла в список в памяти
			li.diskIn(); break;
		case L'к': exit(0); // выход из программы
		default: wcout << L"Неизвестная команда\n";
		}
	}

	return 0;
}

void linklist::additem(int d) // добавление элемента списка
{
	link* newlink = new link; // выделяем память под новый элемент списка
	newlink->data = d;        // сохраняем в него данные
	newlink->next = first;    // указатель на следующий элемент списка
							  // теперь будет указывать на элемент, который
							  // до этого был первым
	first = newlink;          // первым теперь стал только что созданный элемент,
							  // то есть добавление элементов происходит
							  // в начало связанного списка
}

void linklist::display() // вывод на экран данных из всех элементов списка
{
	link* current = first;              // начинаем с первого элемента
	while (current)                     // пока указатель на текущий элемент
	{                                   // не равен NULL (что означает конец списка)
		wcout << current->data << endl; // выводим данные
		current = current->next;        // переходим к следующему элементу
	}
}

void linklist::diskOut() // записать данные элементов списка в файл
{
	// откроем файл для записи
	ofstream outfile; // выходной поток
	outfile.open(L"файл с данными.dat", ios::trunc | ios::binary);
	if (!outfile)
	{
		wcout << L"Не получается открыть файл с данными для записи!";
		exit(-1);
	}
	// пройдем по элементам списка в памяти
	link* current = first;              // начинаем с первого элемента
	while (current)                     // пока указатель на текущий элемент
	{                                   // не равен NULL (что означает конец списка)
										// записать данные текущего элемента в файл
		outfile.write(reinterpret_cast<char*>(&current->data), sizeof(current->data));
		current = current->next;        // переходим к следующему элементу
	}
	// файл будет закрыт автоматически при завершении работы метода
}

void linklist::diskIn() // прочитать данные из файла и записать их в список
{
	// откроем файл для чтения
	ifstream infile; // входной поток
	infile.open(L"файл с данными.dat", ios::ate | ios::binary);
	if (!infile)
	{
		wcout << L"Не получается открыть файл с данными для чтения!";
		exit(-1);
	}
	// удаление старого списка в памяти
	link* current = first;     // начинаем с первого элемента
	while (current)            // пока не конец (NULL) списка
	{
		first = current->next; // первым становится предыдущий элемент
		delete current;        // освобождаем память, занятую текущим элементом
		current = first;       // теперь текущий элемент тот, который ранее
							   // был предыдущим
	}
	// чтение данных из файла и запись их во вновь создаваемый список
	int data;                            // данные элемента списка
	int elsize = sizeof(data);           // размер в байтах данных элемента списка
	int elnum = (int) infile.tellg() / elsize; // количество элементов в файле
	for (int i = elnum; i > 0; i--)      // читаем с конца файла в начало
	{
		infile.seekg(-elsize, ios::cur); // указатель на начало данных элемента
		                                 // считаем данные из файла
		infile.read(reinterpret_cast<char*>(&data), elsize);
		additem(data);                   // и добавим в список
		infile.seekg(-elsize, ios::cur); // указатель на конец следующих данных
	}
	// файл будет закрыт автоматически при завершении работы метода
}