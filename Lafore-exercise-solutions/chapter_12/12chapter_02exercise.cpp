// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 12chapter_02exercise.cpp
// Требуется написать программу, эмулирующую работу команды copy командной
// строки операционной системы (например, в MS DOS есть такая команда).
// Этой команде задаются два параметра: первый является именем копируемого
// файла, второй — именем файла, в который копируется содержимое первого.
// Оба файла являются текстовыми.

// (я добавил в программу строки для работы с локалью, чтобы можно было
// читать русские буквы из файла в кодировке UTF-8 и записывать файл в той
// же кодировке)

#include <io.h>      // для функции _setmode
#include <fcntl.h>   // для константы _O_U16TEXT
#include <fstream>   // для файлового ввода/вывода
#include <iostream>
#include <codecvt>   // для работы с фасетом codecvt_utf8 локали
// #include <locale> // не понадобился
using namespace std;
// #include <process.h> // для функции exit не понадобился

int wmain(int argc, wchar_t* argv[])
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ошибок в формат Юникода
	_setmode(_fileno(stderr), _O_U16TEXT);

	// создаем константу, содержащую локаль с нужным фасетом для
	// преобразования символов при чтении из файла (и записи в файл) в кодировке UTF-8
	const locale utf8_locale = locale(locale(), new codecvt_utf8<wchar_t>());

	// проверим количество параметров: их должно быть три, так как первым
	// параметром является имя исполняемого файла (которое и является командой),
	// второй и третий параметры — имена копируемого файла и файла, в который
	// копируется содержимое первого
	if (argc != 3)
	{
		wcerr << L"Формат команды: ocopy имя_файла_источника имя_файла_приёмника" << endl;
		exit(-1);
		
		// это сообщение об ошибке подразумевает, что исполняемый файл программы
		// называется ocopy.exe
	}

	wifstream infile;           // создать входной поток
	infile.imbue(utf8_locale);  // связываем наш поток с нужной локалью
	infile.open(argv[1]);       // открыть файл для чтения
	if (!infile)                // проверить на ошибки
	{
		wcerr << L"Не получается открыть " << argv[1] << endl;
		exit(-1);
	}

	wofstream outfile;          // создать выходной поток
	outfile.imbue(utf8_locale); // связываем наш поток с нужной локалью
	outfile.open(argv[2]);      // открыть файл для записи
	if (!outfile)               // проверить на ошибки
	{
		wcerr << L"Не получается открыть " << argv[2] << endl;
		exit(-1);
	}

	wchar_t ch;                 // символ для считывания (и записи)
	while (infile.get(ch))      // считать символ (пока не достигнут конец файла)
		outfile.put(ch);        // записать символ в файл

	wcout << L"Выполнено успешно!" << endl;

	return 0;
}