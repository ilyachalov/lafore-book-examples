// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 15chapter_08exercise.cpp
// Алгоритм copy можно использовать для копирования последовательности
// элементов из одного места контейнера в другое место этого же контейнера.
// Однако, следует быть осторожным, когда место назначения последовательности
// в контейнере перекрывает исходное место этой последовательности в этом
// контейнере.

// Требуется написать программу, которая позволяет пользователю скопировать
// любую последовательность внутри массива в другое место этого же массива с
// помощью алгоритма copy. При этом требуется от пользователя получать входные
// данные в виде значений first1 и last1, указывающих в массиве исходное место
// копируемой последовательности элементов, и значения first2, указывающего
// в массиве начало места, в которое следует поместить копируемую
// последовательность.

////////////////////////////////////////////////////////////////////////////////
// Требуется использовать написанную программу для проверки того, что с помощью
// этой программы можно передвинуть последовательность элементов влево от
// исходного места, даже если место назначения частично перекрывает исходное
// место. Требуется показать, что невозможно сделать то же самое с корректным
// результатом, если последовательность элементов передвигается вправо от
// исходного места, если место назначения частично перекрывает исходное место.
// Это следует из того, что алгоритм copy начинает копирование с самого левого
// элемента в копируемой последовательности элементов.
//
// Как оказалось, в моей среде «Visual Studio Community 2017» можно без проблем
// передвигать последовательность элементов хоть вправо, хоть влево от исходного
// места, даже если место назначения частично перекрывает исходное место
// последовательности элементов в контейнере (я проверил на обычном массиве и
// на векторе).
////////////////////////////////////////////////////////////////////////////////

#include <io.h>         // для функции _setmode
#include <fcntl.h>      // для константы _O_U16TEXT
#include <iostream>
using namespace std;

const int MAX = 20; // размер массива

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	// создадим массив целых чисел и заполним его
	int arr[MAX];
	for (int i = 0; i < MAX; i++)
		arr[i] = i;

	// выведем исходное (до копирования) содержимое массива на экран
	wcout << L"Содержимое массива: ";
	for (int i = 0; i < MAX; i++)
		wcout << arr[i] << ((i == MAX - 1) ? L'\n' : L' ');

	// получим у пользователя три индекса элементов в массиве:
	// – first1 и last1 определяют копируемую последовательность [first1, last1],
	// – first2 определяет начало места, в которое будет произведено копирование
	int first1, last1, first2;
	wcout << L"Введите first1, last1 и first2 (через пробел): ";
	wcin >> first1 >> last1 >> first2;

	// проверим индексы first1 и last1 на ошибки

	if (first1 < 0 || first1 >= MAX)
	{
		wcout << L"Ошибка! first1 может быть только в диапазоне 0.." << MAX - 1 << endl;
		exit(1);
	}
	if (last1 < 0 || last1 >= MAX)
	{
		wcout << L"Ошибка! last1 может быть только в диапазоне 0.." << MAX - 1 << endl;
		exit(1);
	}
	if (first1 > last1)
	{
		wcout << L"Ошибка! first1 не может быть больше, чем last1" << endl;
		exit(1);
	}

	// проверим индекс first2 на ошибки

	int len = last1 - first1; // длина копируемой последовательности (минус 1)
	if ((first2 < 0 - len) || (first2 >= MAX))
	{
		wcout << L"Ошибка! При таком first2 последовательность окажется за "
			"пределами массива" << endl;
		exit(1);
	}
	if (first2 < 0)    // хоть начало места назначения за левым пределом массива,
	{                  // конец последовательности попадает в массив
		first1 = first1 - first2;
		first2 = 0;
		wcout << L"! first2 за пределом массива, копирование будет частичным" << endl;
	}
	if (first2 + len >= MAX) // конец места назначения за правым пределом массива,
	{                        // но начало последовательности попадает в массив
		last1 = first1 + (MAX - 1 - first2);
		wcout << L"! last2 за пределом массива, копирование будет частичным" << endl;
	}

	// выполняем копирование с помощью соответствующего алгоритма
	copy(arr + first1, arr + last1 + 1, arr + first2);

	// выведем итоговое (после копирования) содержимое массива на экран
	wcout << L"Содержимое массива: ";
	for (int i = 0; i < MAX; i++)
		wcout << arr[i] << ((i == MAX - 1) ? L'\n' : L' ');
	
	return 0;
}