// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 15chapter_12exercise.cpp
// Имеется текстовый файл. Требуется написать программу, которая запрашивает
// у пользователя имя этого текстового файла, а затем создает для этого файла
// частотную таблицу, представляющую собой список встречающихся в тексте этого
// файла слов и количество вхождений каждого из этих слов.

// Для хранения частотной таблицы предлагается использовать отображение (map)
// с парами строка-число. Для проверки, является ли символ одним из знаков
// препинания, предлагается использовать функцию iswpunct, а для удаления
// найденных знаков препинания из конца слова предлагается использовать
// метод substr строкового класса wstring. Для приведения всех букв слова
// к строчным предлагается использовать функцию towlower.

// Хоть о кодировке текстового файла в задании ничего не сказано, я предполагаю,
// что эта кодировка — UTF-8.

// В задании не сказано, что делать с частотной таблицей в конце программы.
// Я решил вывести ее на экран. Другой вариант может быть — вывести в файл. Но
// я не стал этого делать, так как вывод текста в файл я уже делал и в этой
// главе, и в предыдущих главах.

#include <io.h>      // для функции _setmode
#include <fcntl.h>   // для константы _O_U16TEXT
#include <iostream>  // для работы со стандартными потоками wcin, wcout и wcerr
#include <string>    // для работы с классом wstring
#include <fstream>   // для работы с файловыми потоками
#include <map>       // для контейнера map (отображение)
#include <iterator>  // для потоковых итераторов istream_iterator
                     // и ostream_iterator
#include <codecvt>   // для работы с фасетом codecvt_utf8 локали
#include <iomanip>   // для манипулятора потока setw
using namespace std;

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);
	// переключение стандартного потока ошибок в формат Юникода
	_setmode(_fileno(stderr), _O_U16TEXT);

	// получим от пользователя имя текстового файла
	wstring fname; // имя файла
	wcout << L"Введите имя текстового файла: ";
	getline(wcin, fname);

	// создаем константу, содержащую локаль с нужным фасетом для
	// преобразования символов при чтении из файла в кодировке UTF-8
	const locale utf8_locale = locale(locale(), new codecvt_utf8<wchar_t>());

	// откроем текстовый файл для чтения
	wifstream infile(fname);   // входной поток
	infile.imbue(utf8_locale); // связываем наш поток с нужной локалью
	if (!infile)
		{ wcerr << L"Не получается открыть текстовый файл для чтения\n"; exit(1); }

	map<wstring, int> freq_table;          // частотная таблица (отображение)
	map<wstring, int>::iterator freq_iter; // итератор отображения

	// создаем нужные потоковые итераторы
	istream_iterator<wstring, wchar_t> is_iter(infile); // итератор входного потока
	istream_iterator<wstring, wchar_t> end_of_stream;   // итератор конца входного потока

	// считываем слова из текстового файла в частотную таблицу и подсчитываем
	// количество вхождений каждого слова, которое тоже помещаем в частотную таблицу
	// 1. словами считаются последовательности символов, разделенные пробельными символами
	//    (пробел, перевод строки, табулятор);
	// 2. после применения 1-го пункта оказывается, что знаки препинания (точки, запятые
	//    восклицательные знаки, вопросительные знаки и т.д.) входят в состав слов,
	//    поэтому последние символы каждого слова следует проверить, являются ли они
	//    знаками препинания (может быть и несколько знаков препинания, например,
	//    многоточие, знак !? и тому подобное) и если да, то их следует удалить;
	// 3. слово, начинающееся с заглавной буквы, на самом деле, это то же самое слово,
	//    что и начинающееся со строчной буквы, например, «Река» и «река», поэтому
	//    до помещения слов в отображение буквы слов следует «привести к общему
	//    знаменателю»; я решил сделать их строчными
	wstring word; // для очередного слова из файла
	int nw = 0;   // общее количество слов в файле
	while (is_iter != end_of_stream)
	{
		word = *is_iter++;  // получаем очередное слово, итератор переводим дальше

		// убираем знаки препинания (их может быть несколько) из конца слова
		int i = word.length() - 1;          // начинаем с последнего символа слова
		while (i >= 0 && iswpunct(word[i])) // найдем номер первого символа с конца
			i--;                            // слова, не являющегося знаком препинания
		word = word.substr(0, i + 1);       // оставляем слово без знаков препинания в конце
		
		if (word.empty())                   // если всё слово состояло из знаков
			continue;                       // препинания, перейти в цикле к следующему
		                                    // слову, не помещая пустое слово в отображение

		// если не установить русскую локаль для категории LC_CTYPE,
		// функция towlower сработает только для латиницы, так как эта
		// функция является локалезависимой, а по умолчанию для программ
		// на языке C++ устанавливается локаль "C" (латинская буква "C"),
		// при которой символы интерпретируются как однобайтовые со значением
		// всегда меньше 256
		setlocale(LC_CTYPE, "ru-RU");

		// делаем все буквы слова строчными
		for (i = 0; i < word.length(); i++)
			word[i] = towlower(word[i]);

		freq_table[word]++; // помещаем слово в отображение (при этом второй член пары,
		                    // счетчик, инициализируется нулем) и увеличиваем счетчик
		
		nw++;               // считаем общее количество слов в файле
	}

	wcout << L"\nЧастотная таблица для этого файла:\n\n"
		<< L"  всего слов:        " << nw
		<< L"\n  из них уникальных: " << freq_table.size() << endl << endl;
	
	// выводим частотную таблицу (отображение) на экран
	for (freq_iter = freq_table.begin(); freq_iter != freq_table.end(); freq_iter++)
		wcout << setw(3) << (*freq_iter).second << L' ' << (*freq_iter).first << endl;

	return 0;
}