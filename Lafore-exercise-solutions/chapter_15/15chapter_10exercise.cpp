// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 15chapter_10exercise.cpp
// Имеется программа из упражнения 8 текущей (15-й) главы, которая позволяет
// пользователю скопировать любую последовательность элементов внутри массива
// в другое место этого же массива с помощью алгоритма copy.

// В задании к упражнению 8 требовалось показать, что невозможно с помощью
// алгоритма copy скопировать (передвинуть) с корректным результатом заданную
// последовательность элементов вправо от исходного места последовательности,
// если место назначения перекрывается с исходным местом последовательности.
// Причиной этого называлось то, что алгоритм copy начинает копирование с самого
// левого элемента заданной последовательности элементов. Но оказалось, что
// в моей среде разработки «Visual Studio Community 2017» алгоритм copy выполняет
// указанную проблемную задачу без ошибок. (В стандарте языка C++, на самом деле,
// сказано, что в этом случае поведение алгоритма copy стандартом не определено,
// то есть отдано на откуп конкретной реализации компилятора, а в компиляторе из
// набора среды «Visual Studio Community 2017» алгоритм copy запрограммирован в
// указанном случае выполнять копирование корректно.)

// В задании к текущему (10-му) упражнению текущей (15-й) главы предлагается для
// решения указанной проблемной задачи использовать вместо алгоритма copy алгоритм
// copy_backward. Этот алгоритм начинает копирование последовательности с самого
// правого элемента последовательности, поэтому у этого алгоритма все свойства и
// проблемы отзеркаливаются, если сравнивать с алгоритмом copy. То есть поведение
// алгоритма copy_backward не определено стандартом C++ при копировании последо-
// вательности элементов влево, если исходное место перекрывается с местом назна-
// чения.

// Требуется написать программу, которая использует и алгоритм copy, и алгоритм
// copy_backward и позволяет копирование заданной последовательности элементов
// внутри одного и того же контейнера независимо от того, перекрывается ли
// исходное место последовательности с местом назначения или не перекрывается.

// Я решил не писать новую программу, а переписать программу из упомянутого выше
// упражнения 8 текущей (15-й) главы.

#include <io.h>         // для функции _setmode
#include <fcntl.h>      // для константы _O_U16TEXT
#include <iostream>
using namespace std;

const int MAX = 20; // размер массива

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	// создадим массив целых чисел и заполним его
	int arr[MAX];
	for (int i = 0; i < MAX; i++)
		arr[i] = i;

	// выведем исходное (до копирования) содержимое массива на экран
	wcout << L"Содержимое массива: ";
	for (int i = 0; i < MAX; i++)
		wcout << arr[i] << ((i == MAX - 1) ? L'\n' : L' ');

	// получим у пользователя три индекса элементов в массиве:
	// – first1 и last1 определяют копируемую последовательность [first1, last1],
	// – first2 определяет начало места, в которое будет произведено копирование
	int first1, last1, first2;
	wcout << L"Введите first1, last1 и first2 (через пробел): ";
	wcin >> first1 >> last1 >> first2;

	// проверим индексы first1 и last1 на ошибки

	if (first1 < 0 || first1 >= MAX)
	{
		wcout << L"Ошибка! first1 может быть только в диапазоне 0.." << MAX - 1 << endl;
		exit(1);
	}
	if (last1 < 0 || last1 >= MAX)
	{
		wcout << L"Ошибка! last1 может быть только в диапазоне 0.." << MAX - 1 << endl;
		exit(1);
	}
	if (first1 > last1)
	{
		wcout << L"Ошибка! first1 не может быть больше, чем last1" << endl;
		exit(1);
	}

	// проверим индекс first2 на ошибки

	if (first2 == first1)
	{
		wcout << L"Ошибка! В операции нет смысла при копировании в то же место" << endl;
		exit(1);
	}

	int len = last1 - first1; // длина копируемой последовательности (минус 1)
	if ((first2 < 0 - len) || (first2 >= MAX))
	{
		wcout << L"Ошибка! При таком first2 последовательность окажется за "
			"пределами массива" << endl;
		exit(1);
	}
	if (first2 < 0)    // хоть начало места назначения за левым пределом массива,
	{                  // конец последовательности попадает в массив
		first1 = first1 - first2;
		first2 = 0;
		wcout << L"! first2 за пределом массива, копирование будет частичным" << endl;
	}
	if (first2 + len >= MAX) // конец места назначения за правым пределом массива,
	{                        // но начало последовательности попадает в массив
		last1 = first1 + (MAX - 1 - first2);
		wcout << L"! last2 за пределом массива, копирование будет частичным" << endl;
	}

	// выполняем копирование
	if (first2 >= first1 && first2 <= last1) // проблемный для алгоритма copy случай
	{
		wcout << L"! Работает алгоритм copy_backward" << endl;
		copy_backward(arr + first1, arr + last1 + 1, arr + first2 + (last1 - first1) + 1);
	}
	else                                     // все остальные случаи
		copy(arr + first1, arr + last1 + 1, arr + first2);

	// Отмечу, что первые два аргумента алгоритма copy_backward совпадают с
	// первыми двумя аргументами алгоритма copy. Третий аргумент для алгоритма
	// copy_backward — индекс элемента «за последним» места назначения, а третий
	// аргумент алгоритма copy — индекс первого элемента места назначения.

	// выведем итоговое (после копирования) содержимое массива на экран
	wcout << L"Содержимое массива: ";
	for (int i = 0; i < MAX; i++)
		wcout << arr[i] << ((i == MAX - 1) ? L'\n' : L' ');
	
	return 0;
}