// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 06chapter_12exercise.cpp
// программа запрашивает знаменатель обыкновенной дроби у пользователя,
// а затем выводит таблицу умножения для обыкновенных дробей с полученным знаменателем,
// множители подбираются в таблицу с числителем в пределах от 1 до полученного знаменателя
// (в программе следует использовать класс fraction из упражнения 11 главы 6)

#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT
#include <iostream>
using namespace std;

class fraction // класс, представляющий обыкновенную дробь
{
private:
	int num; // числитель
	int den; // знаменатель
public:
	// конструктор без аргументов
	fraction()
		{ }
	// конструктор с двумя аргументами
	fraction(int n, int d) : num(n), den(d)
		{ lowterms(); }
	// метод для получения данных класса от пользователя с клавиатуры
	void get()
	{
		wchar_t slash; // для косой черты
		wcout << L"Введите обыкновенную дробь (в формате числитель/знаменатель): ";
		wcin >> num >> slash >> den;
		lowterms();
	}
	// константный метод выводит поля объекта класса на экран
	// width — ширина столбца таблицы в символах (по умолчанию — 5)
	void display(int width = 5) const
	{
		int i = 1, tnum = num, tden = den;
		// подсчитаем, сколько символов требуется для дроби
		while (tnum)
			{ tnum = tnum / 10; i++; }
		while (tden)
			{ tden = tden / 10; i++; }
		wcout << num << L'/' << den; // выводим дробь
		// выводим столько пробелов, сколько не хватает до ширины столбца таблицы
		for (int j = 1; j <= (width - i); j++)
			wcout << L' ';
	}
	// метод для сложения двух обыкновенных дробей
	void add(fraction f1, fraction f2)
	{
		num = f1.num * f2.den + f2.num * f1.den;
		den = f1.den * f2.den;
		lowterms();
	}
	// метод для нахождения разности двух обыкновенных дробей
	void sub(fraction f1, fraction f2)
	{
		num = f1.num * f2.den - f2.num * f1.den;
		den = f1.den * f2.den;
		lowterms();
	}
	// метод для умножения двух обыкновенных дробей
	void mul(fraction f1, fraction f2)
	{
		num = f1.num * f2.num;
		den = f1.den * f2.den;
		lowterms();
	}
	// метод для нахождения результата от деления одной обыкновенной дроби на другую
	void div(fraction f1, fraction f2)
	{
		num = f1.num * f2.den;
		den = f1.den * f2.num;
		lowterms();
	}
	// метод (прототип) для сокращения дроби до несократимого вида
	void lowterms();
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	int den; // знаменатель обыкновенной дроби, получаемый от пользователя
	wcout << L"Введите знаменатель обыкновенной дроби (положительный, больше 1): "; wcin >> den;
	wcout << endl;

	// вычислим необходимую максимальную ширину width1 левого заголовочного столбца таблицы
	int width1 = 1; // один символ уйдет на косую черту
	int tnum = den - 1, tden = den;
	while (tnum) // вычисляем максимальную ширину числителя
		{ tnum = tnum / 10; width1++; }
	while (tden) // вычисляем максимальную ширину знаменателя
		{ tden = tden / 10; width1++; }

	// вычислим необходимую максимальную ширину width2 ячеек таблицы
	int width2 = 1; // один символ уйдет на косую черту
	tnum = den * den - 1, tden = den * den;
	while (tnum) // вычисляем максимальную ширину числителя
		{ tnum = tnum / 10; width2++; }
	while (tden) // вычисляем максимальную ширину знаменателя
		{ tden = tden / 10; width2++; }

	// вывод таблицы
	// выводим пустое место над левым заголовочным столбцом
	for (int i = 1; i <= width1; i++)
		wcout << L' ';
	wcout << L"  ";
	// выводим ячейки верхней строки
	for (int num1 = 1; num1 < den; num1++)
	{
		fraction f1(num1, den);
		wcout << L' '; f1.display(width2);
	}
	wcout << endl;
	// вывод разделителя верхней строки и ячеек таблицы
	for (int i = 1; i <= (width1 + 2 + (width2 + 1) * (den - 1)); i++)
		wcout << L'-';
	wcout << endl;
	// вывод левого заголовочного столбца и ячеек
	for (int num1 = 1; num1 < den; num1++)
	{
		fraction f1(num1, den);
		f1.display(width1); wcout << L" |"; // выводим левый заголовочный столбец

		for (int num2 = 1; num2 < den; num2++)
		{
			fraction f2(num2, den), f;
			f.mul(f1, f2);
			wcout << L' '; f.display(width2); // выводим ячейку таблицы
		}
		wcout << endl; // переход на следующую строку таблицы
	}

	return 0;
}

// метод для сокращения дроби до несократимого вида
void fraction::lowterms()
{
	long tnum, tden, // две временные переменные для хранения числителя и знаменателя
		 temp,       // временная переменная для хранения значения при обмене
		 gcd;        // наибольший общий делитель, который нужно найти (greatest common divisor)

	tnum = labs(num); // возьмем значения числителя и знаменателя по модулю
	tden = labs(den); // (заголовочный файл cmath для функции labs не понадобился)
	
	if (tden == 0) // проверка знаменателя на 0
		{ cout << "Недопустимый знаменатель!"; exit(1); }
	else if (tnum == 0) // проверка числителя на 0
		{ num = 0; den = 1; return;	}

	// нахождение наибольшего общего делителя (Алгоритм Евклида)
	while (tnum != 0)
	{
		// добьемся, чтобы числитель был больше
		if (tnum < tden)                               // если числитель меньше знаменателя,
			{ temp = tnum; tnum = tden; tden = temp; } // меняем их местами
		
		tnum = tnum - tden;
	}
	gcd = tden;

	num = num / gcd; // делим числитель и знаменатель на
	den = den / gcd; // полученный наибольший общий делитель
}