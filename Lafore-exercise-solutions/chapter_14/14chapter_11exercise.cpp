// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 14chapter_11exercise.cpp
// Имеется программа-пример 323_strplus.cpp из 8-й главы. В ней создан класс
// String, представляющий строку (массив символов). Для этого класса
// перегружена операция бинарного сложения (+). Требуется добавить класс
// исключения в класс String и генерировать исключение в конструкторе с одним
// аргументом класса String, если заданная аргументом строка превышает по
// длине массив. Требуется также генерировать исключение в операции сложения,
// если строка-результат сложения превысит по длине массив. Сообщение об ошибке
// в этих двух случаях должно давать информацию о том, какая именно ошибка
// произошла.

// для использования небезопасных функций wcscpy и wcscat
#define _CRT_SECURE_NO_WARNINGS

#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT
#include <iostream>
using namespace std;
// #include <string.h> // для функций wcscpy, wcslen и wcscat не понадобился

class String // класс, представляющий строку (массив символов)
{
private:
	static const int SZ = 80; // максимальный размер строки
							  // (одна константа для всех объектов, статическая)
	wchar_t str[SZ];          // сама строка
public:
	class StrEx               // класс исключения
	{
	public:
		int num;              // номер ошибки
		StrEx(int n) : num(n) // конструктор исключения
			{ }
	};

	String()                          // конструктор без аргументов
		{ str[0] = L'\0'; }
	String(const wchar_t s[])         // конструктор с одним аргументом
	{
		if (wcslen(s) < SZ)
			wcscpy(str, s);
		else
			throw StrEx(1);           // генерируем исключение 1
	}
	void display() const              // показ строки на экране
		{ wcout << str; }
	String operator+ (String s) const // операция сложения
	{
		String temp; // временная переменная
		if (wcslen(str) + wcslen(s.str) < SZ)
		{
			wcscpy(temp.str, str);    // копируем содержимое первой строки
			wcscat(temp.str, s.str);  // добавляем содержимое второй строки
		}
		else
			throw StrEx(2);           // генерируем исключение 2
		return temp; // возвращаем результат
	}
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);

	try
	{
		String s1(L"С Рождеством! ");  // конструктор с одним параметром
		String s2 = L"С Новым годом!"; // аналогично, но в другой форме
		String s3;                     // конструктор без параметров
		//String s4 = L"За горами, за лесами, за широкими морями, не на небе — на земле "
		//	"жил старик в одном селе."; // для проверки генерации исключения 1

		s1.display(); // показываем все строки
		s2.display();
		s3.display();
		wcout << endl;

		s3 = s1 + s2; // присваиваем строке s3 результат сложения строк s1 и s2

		              // для проверки генерации исключения 2
		//s3 = s3 + L" " + s2 + L" " + s2 + L" " + s2 + L" " + s2;

		s3.display(); // показываем результат
		wcout << endl;
	}
	catch (String::StrEx err)
	{
		switch (err.num)
		{
		case 1: wcout << L"Конструктор: ошибка! Строка слишком длинная.\n"; break;
		case 2: wcout << L"Сложение: ошибка! Результат сложения слишком длинный.\n"; break;
		}
		exit(1);
	}

	return 0;
}