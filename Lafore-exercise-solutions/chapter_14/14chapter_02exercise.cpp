// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 14chapter_02exercise.cpp
// Требуется написать шаблон класса, представляющего очередь. Очередь требуется
// реализовать с помощью массива с фиксированным числом элементов; также
// используются два индекса, один из которых указывает на начало очереди,
// другой — на конец очереди. В функции main требуется протестировать
// этот шаблон класса на разных типах данных.

// Замечу, что в упражнении 9 к главе 7 уже было задание создать класс,
// реализующий такую очередь. В качестве базы для нашего шаблона я взял
// класс, созданный при выполнении того упражнения.

#include <io.h>      // для функции _setmode
#include <fcntl.h>   // для константы _O_U16TEXT
#include <iostream>
using namespace std;

template<class T>    // шаблон класса, реализующего очередь
class queue
{
private:
	static const int MAX = 10; // количество элементов в массиве
	                           // (одна константа для всех объектов, статическая)
	T q[MAX];                  // очередь в виде массива
	int head;                  // элемент в начале очереди
	int tail;                  // элемент в конце очереди
	
	int length;                // длина очереди (количество элементов в ней)
	                           // (это поле класса по условиям задания не требуется,
	                           // но используем его для того, чтобы обезопасить работу
	                           // с очередью)
public:
	queue()                    // конструктор
	{
		// очередь пуста
		head = 0; tail = -1;
		length = 0;
	}
	void put(T var);           // поместить в очередь
	T get();                   // взять из очереди
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);

	queue<int> q1;     // создадим очередь с элементами типа int

	q1.put(-1); q1.put(0); q1.put(1); q1.put(2);
	
	wcout << L"int: " << q1.get() << L' ';
	wcout << q1.get() << L' ';
	wcout << q1.get() << L' ';
	wcout << q1.get() << endl;

	queue<double> q2;  // создадим очередь с элементами типа double

	q2.put(-0.487); q2.put(0.5); q2.put(102.45);

	wcout << L"double: " << q2.get() << L' ';
	wcout << q2.get() << L' ';
	wcout << q2.get() << endl;

	queue<wchar_t> q3; // создадим очередь с элементами типа wchar_t

	q3.put(L'И'); q3.put(L'л'); q3.put(L'ь'); q3.put(L'я');

	wcout << L"wchar_t: " << q3.get() << L' ';
	wcout << q3.get() << L' ';
	wcout << q3.get() << L' ';
	wcout << q3.get() << endl;

	return 0;
}

template<class T>
void queue<T>::put(T var) // поместить в очередь
{
	// при переполнении очереди произойдет выход из программы с сообщением
	if (length == MAX)
	{
		wcout << L"Очередь не может содержать больше " << MAX << L" элементов!";
		exit(1);
	}

	// если перед добавлением элемента конец очереди совпадает с концом массива,
	// то перебрасываем конец очереди в начало массива
	if (tail == MAX - 1)
		tail = -1;

	q[++tail] = var; length++;
}

template<class T>
T queue<T>::get()         // взять из очереди
{
	// при попытке взять из пустой очереди произойдет выход из программы с сообщением
	if (length == 0)
	{
		wcout << L"Вы попытались взять из пустой очереди!";
		exit(1);
	}

	T var = q[head++]; length--;

	// если после извлечения элемента из очереди индекс начала очереди вышел
	// за конец массива, перебросим его в начало массива
	if (head == MAX)
		head = 0;

	return var;
}