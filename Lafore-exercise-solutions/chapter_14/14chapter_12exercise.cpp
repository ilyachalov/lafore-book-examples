// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 14chapter_12exercise.cpp
// Имеется программа из примера 568_rewerr.cpp 12-й главы. В этой программе
// не создаётся никаких пользовательских классов, а используются стандартные
// для C++ классы потокового ввода-вывода для работы с файлами данных в
// двоичном (ios::binary) режиме: ofstream и ifstream, чтобы продемонстрировать
// работу с ними, а также обработку возможных ошибок.

// Требуется написать класс dofile, включающий методы для записи в файл и
// чтения из файла, а также класс исключения для обработки ошибок, которые
// могут возникнуть при записи в файл и чтении из файла. Конструктор этого
// класса должен принимать в качестве аргумента имя файла и открывать файл с
// этим именем. Требуется написать метод, который будет устанавливать указатель
// позиции в файле на начало файла. Требуется в функции main переписать
// программу из примера 568_rewerr.cpp 12-й главы так, чтобы она использовала
// класс dofile и механизм исключений, а функционал этой программы должен
// остаться прежним.

// (Создание класса dofile будет являться иллюстрацией утверждения, приведенного
// в начале задания к текущему упражнению: «Иногда проще всего бывает использо-
// вать механизм исключений, если создать новый класс, чьим компонентом является
// класс исключений. Попробуйте проделать такую операцию с классом, использующим
// исключения для обработки файловых ошибок.»)

/////// Пояснения к примеру 568_rewerr.cpp 12-й главы //////////////////////////
// обработка ошибок во время вывода в файл и чтения из файла
//
// В книге Лафоре в этой программе используется путь к файлу "a:данные.dat".
// Я заменил его на "g:\\данные.dat". Книга писалась много лет назад, когда
// буква "a" в настольных компьютерах была обычно занята под дисковод для дискет.
// Я попытался заменить на "c", которая обычно обозначает основной жесткий диск
// с операционной системой, но это неудобно, потому что для записи файла на этот
// диск программа в Windows должна обладать правами администратора. Поэтому
// я выбрал букву "g", по которой у меня к компьютеру подключен через USB внешний
// жесткий диск. Это удобно еще и для тестирования — я могу отключить этот диск
// и тогда программа должна сообщить об ошибке при попытке открытия файла для
// записи.
//
// Обратную косую черту (\) пришлось написать двойной (\\), так как ее можно
// изобразить только такой управляющей последовательностью в строке.
////////////////////////////////////////////////////////////////////////////////

#include <io.h>      // для функции _setmode
#include <fcntl.h>   // для константы _O_U16TEXT
#include <fstream>   // для файлового ввода/вывода
#include <iostream>
using namespace std;
// #include <process.h> // для функции exit не понадобился

class dofile      // класс, использующий исключения при обработке
                  // ошибок, которые могут произойти при работе с файлами
{
private:
	fstream file; // поток и для чтения, и для записи в файл
public:
	class fileEx  // класс исключения
	{
	public:
		int num;               // номер ошибки
		fileEx(int n) : num(n) // конструктор
			{ }
	};
	dofile(const wchar_t* filename) // конструктор
	{
		// открываем файл и для чтения, и для записи в двоичном режиме
		// (ios::trunc — при открытии содержимое файла стирается)
		file.open(filename, ios::trunc | ios::out | ios::in | ios::binary);
		if (!file)
			throw fileEx(1);
	}
	void write(int* data, int n) // метод для записи в файл
	{
		file.write(reinterpret_cast<char*>(data), n * sizeof(int));
		if (!file)
			throw fileEx(2);
	}
	void read(int* data, int n)  // метод для чтения из файла
	{
		file.read(reinterpret_cast<char*>(data), n * sizeof(int));
		if (!file)
			throw fileEx(3);
	}
	void to_beg_for_get() // установка указателя позиции в файле (для чтения)
	{
		// 0 — смещение от (по умолчанию) ios::beg (от начала файла),
		// то есть это выражение устанавливает указатель позиции в файле
		// на его начало (для чтения)
		file.seekg(0);
	}
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ошибок в формат Юникода
	_setmode(_fileno(stderr), _O_U16TEXT);

	const int MAX = 1000;
	int buff[MAX];                     // массив-буфер для тестовых данных

	for (int j = 0; j < MAX; j++)      // заполним буфер тестовыми данными
		buff[j] = j;
	
	try
	{
		dofile f(L"g:\\данные.dat");   // свяжем поток с файлом для записи в него
									   // и чтения из него; откроем файл
		wcout << L"Идет запись...\n";
		f.write(buff, MAX);            // запишем в файл содержимое буфера

		for (int j = 0; j < MAX; j++)  // очистим буфер
			buff[j] = 0;

		f.to_beg_for_get();            // установим указатель позиции в файле
									   // на его начало (для чтения)
		wcout << L"Идет чтение...\n";
		f.read(buff, MAX);             // получим данные из файла в буфер
	}
	catch (dofile::fileEx err)         // обработка исключений
	{
		switch (err.num)
		{
		case 1: wcerr << L"Не получается открыть файл\n"; break;
		case 2: wcerr << L"Не получается записать в файл\n"; break;
		case 3: wcerr << L"Не получается прочитать из файла\n"; break;
		}
		exit(1);                       // завершение программы с ошибкой
	}

	for (int j = 0; j < MAX; j++)      // проверим данные
		if (buff[j] != j)
			{ wcerr << L"\nДанные некорректны\n"; exit(1); }
	wcout << L"Данные в порядке\n";

	return 0;
}