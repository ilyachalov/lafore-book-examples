// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// rewerr.cpp
// обработка ошибок во время вывода в файл и чтения из файла

// В книге Лафоре в этой программе используется путь к файлу "a:данные.dat".
// Я заменил его на "g:\\данные.dat". Книга писалась много лет назад, когда
// буква "a" в настольных компьютерах была обычно занята под дисковод для дискет.
// Я попытался заменить на "c", которая обычно обозначает основной жесткий диск
// с операционной системой, но это неудобно, потому что для записи файла на этот
// диск программа в Windows должна обладать правами администратора. Поэтому
// я выбрал букву "g", по которой у меня к компьютеру подключен через USB внешний
// жесткий диск. Это удобно еще и для тестирования — я могу отключить этот диск
// и тогда программа должна сообщить об ошибке при попытке открытия файла для
// записи.

// Обратную косую черту (\) пришлось написать двойной (\\), так как ее можно
// изобразить только такой управляющей последовательностью в строке.

#include <io.h>      // для функции _setmode
#include <fcntl.h>   // для константы _O_U16TEXT
#include <fstream>   // для файлового ввода/вывода
#include <iostream>
using namespace std;
// #include <process.h> // для функции exit не понадобился

const int MAX = 1000;
int buff[MAX];

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ошибок в формат Юникода
	_setmode(_fileno(stderr), _O_U16TEXT);

	for (int j = 0; j < MAX; j++)  // заполним буфер данными
		buff[j] = j;
	ofstream os;                   // создадим выходной поток
	                               // и откроем его
	os.open(L"g:\\данные.dat", ios::trunc | ios::binary);
	if (!os)
		{ wcerr << L"Не получается открыть файл для записи\n"; exit(1); }

	wcout << L"Идет запись...\n";  // запишем в него содержимое буфера
	os.write(reinterpret_cast<char*>(buff), MAX * sizeof(int));
	if (!os)
		{ wcerr << L"Не получается записать в файл\n"; exit(1); }
	os.close();                    // надо закрыть поток

	for (int j = 0; j < MAX; j++)  // очистим буфер
		buff[j] = 0;

	ifstream is;                   // создадим входной поток
	is.open(L"g:\\данные.dat", ios::binary);
	if (!is)
		{ wcerr << L"Не получается открыть файл для чтения\n"; exit(1); }

	wcout << L"Идет чтение...\n";  // получим данные из файла в буфер
	is.read(reinterpret_cast<char*>(buff), MAX * sizeof(int));
	if (!is)
		{ wcerr << L"Не получается прочитать из файла\n"; exit(1); }

	for (int j = 0; j < MAX; j++)  // проверим данные
		if (buff[j] != j)
			{ wcerr << L"\nДанные некорректны\n"; exit(1); }
	wcout << L"Данные в порядке\n";

	return 0;
}