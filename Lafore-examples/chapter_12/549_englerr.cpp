// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// englerr.cpp
// контроль ввода данных для класса интервала (длины) в английской системе мер

// в комментариях используется понятие «пробельные символы» (white space), которое
// включает пробелы, символы табуляции, символы новой строки

#include <io.h>       // для функции _setmode
#include <fcntl.h>    // для константы _O_U16TEXT
#include <iostream>
#include <string>     // для работы с классом wstring
// #include <cstdlib> // для функций _wtoi, _wtof не понадобился
using namespace std;

int isFeet(wstring);  // предварительное объявление функции

class Distance // интервал (длина) в английской системе мер
{
private:
	int feet;     // футы (1 фут = 12 дюймов)
	float inches; // дюймы
public:
	// конструктор без аргументов
	Distance() : feet(0), inches(0.0)
		{ }
	// конструктор с двумя аргументами
	Distance(int ft, float in) : feet(ft), inches(in)
		{ }
	void showdist() const // вывод интервала на экран
		{ wcout << feet << L"\'-" << inches << L'\"'; }
	void getdist();       // метод для получения интервала у пользователя
};

// метод для получения интервала у пользователя
void Distance::getdist()
{
	wstring instr; // для входной строки

	// бесконечный цикл для проверки футов (выход — с помощью оператора break)
	while (true)
	{
		wcout << L"Введите футы: ";
		wcin.unsetf(ios::skipws);        // не пропускать пробельные символы
		wcin >> instr;                   // получить футы как строку
		// если футы введены правильно, то
		if (isFeet(instr))
		{
			wcin.ignore(10, L'\n');      // стереть оставшиеся в wcin непрочитанные символы,
			                             // включая символ новой строки
			feet = _wtoi(instr.c_str()); // преобразовать введенную пользователем и
			                             // проверенную нами строку в целое число,
			                             // это и будет число футов,
			break;                       // выйти из цикла проверки футов
		}
		// иначе: введенная строка не прошла проверку (не является целым числом)
		wcin.clear();                    // очистить биты ошибок
		                                 // (эта команда в книге в этом месте ошибочно пропущена)
		wcin.ignore(10, L'\n');          // стереть оставшиеся в wcin непрочитанные символы,
		                                 // включая символ новой строки
		wcout << L"Футы должны быть целым числом, меньшим, чем 1000\n";
	}

	// бесконечный цикл для проверки дюймов (выход — с помощью оператора break)
	while (true)
	{
		wcout << L"Введите дюймы: ";
		wcin.unsetf(ios::skipws);        // не пропускать пробельные символы
		wcin >> inches;                  // получить дюймы (тип float)
		// если введенное значение дюймов не попадает в правильный диапазон, то
		if (inches >= 12.0 || inches < 0.0)
		{
			wcout << L"Дюймы должны быть между 0.0 и 11.99\n";
			wcin.clear(ios::failbit);    // «искусственно» установить флаг ошибки
		}
		// если пользователь ввел дюймы без ошибок (бывает, что вводят буквы вместо цифр)
		if (wcin.good())
		{
			wcin.ignore(10, L'\n');      // стереть оставшиеся в wcin непрочитанные символы,
			                             // включая символ новой строки
			break;                       // выйти из цикла проверки дюймов
		}
		// иначе: ввод ошибочен
		wcin.clear();                    // очистить биты ошибок
		wcin.ignore(10, L'\n');          // стереть оставшиеся в wcin непрочитанные символы,
		                                 // включая символ новой строки
		wcout << L"Неверно введены дюймы\n";
	}
}

// функция для проверки строки с числом футов, введенной пользователем
// [возвращает 1 (true), если всё введено верно, иначе — 0 (false)]
int isFeet(wstring str)
{
	int slen = str.size();         // получим длину строки
	// если ничего не введено или введено слишком много символов, то
	if (slen == 0 || slen > 5)
		return 0;                  // завершить работу функции; возвратить false
	// проверим каждый символ строки
	for (int j = 0; j < slen; j++)
		// если не цифра и не минус, то
		if ((str[j] < L'0' || str[j] > L'9') && str[j] != L'-')
			return 0;              // завершить работу функции; возвратить false
	// пока всё в порядке, поэтому
	double n = _wtof(str.c_str()); // преобразуем строку в число типа double
	// если полученное число не укладывается в правильный диапазон, то
	if (n < -999.0 || n > 999.0)
		return 0;                  // завершить работу функции; возвратить false
	// успешно пройдены все проверки, поэтому
	return 1;                      // завершить работу функции; возвратить true
}

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	Distance d;                        // создадим объект класса Distance
	wchar_t ans;

	do
	{
		d.getdist();                   // получим его значение от пользователя
		wcout << L"Интервал = ";
		d.showdist();                  // выведем его на экран
		wcout << L"\nЕщё раз (д/н)? ";
		wcin >> ans;
		wcin.ignore(10, L'\n');        // сотрём оставшиеся в wcin непрочитанные символы,
		                               // включая символ новой строки
	} while (ans != L'н');             // выход из цикла — по нажатию 'н'
	
	return 0;
}