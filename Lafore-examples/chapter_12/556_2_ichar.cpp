// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// ichar.cpp
// чтение из файла посимвольно

// я добавил в программу две строки для работы с локалью, чтобы можно было
// читать русские буквы из файла в кодировке UTF-8

#include <io.h>      // для функции _setmode
#include <fcntl.h>   // для константы _O_U16TEXT
#include <fstream>   // для файлового ввода/вывода
#include <iostream>
#include <codecvt>   // для работы с фасетом codecvt_utf8 локали
// #include <locale> // не понадобился
using namespace std;

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	
	// создаем константу, содержащую локаль с нужным фасетом для
	// преобразования символов при чтении из файла в кодировке UTF-8
	const locale utf8_locale = locale(locale(), new codecvt_utf8<wchar_t>());

	wchar_t ch; // считываемый символ

	wifstream infile(L"тестовый файл.txt"); // создать поток, связанный с нужным файлом
	infile.imbue(utf8_locale);              // связываем наш поток с нужной локалью
	
	// В этом примере в учебнике здесь допущена ошибка. Если написать цикл while так,
	// как показано в учебнике, то последний символ считанного из файла текста будет
	// выведен на экран консоли ДВАЖДЫ. Я переписал цикл так, чтобы он работал правильно.

	// НЕПРАВИЛЬНЫЙ ВАРИАНТ:

	//while (infile) // пока не достигнут конец файла или не случилась какая-нибудь ошибка
	//{
	//	infile.get(ch); // извлекать из файла очередной символ
	//	wcout << ch;    // и выводить его на экран
	//}

	// ПРАВИЛЬНЫЙ ВАРИАНТ:

	while (infile.get(ch)) // Считывать символы из файла, пока при этом не возникла ошибка
		                   // (или не достигнут конец файла).
		wcout << ch;       // Если всё в порядке, вывести считанный символ на экран.

	wcout << endl;

	return 0;
}