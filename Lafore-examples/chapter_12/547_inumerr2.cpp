// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// inumerr2.cpp
// обработка ошибок при вводе чисел
// (выключение флага ios::skipws)

#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT
#include <iostream>
using namespace std;

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	int i; // целое число

	while (true) // бесконечный цикл (выход — с помощью оператора break)
	{
		wcout << L"\nВведите целое число: ";
		wcin.unsetf(ios::skipws); // не пропускать пробельные символы
		wcin >> i;

		// если при вводе не было совершено ошибок
		if (wcin.good())
		{
			wcin.ignore(10, L'\n'); // удалить разделитель строк
			break;                  // выйти из цикла
		}
		
		// при вводе совершены ошибки
		wcin.clear();                         // очистить биты ошибок
		wcout << L"Неправильный ввод данных";
		wcin.ignore(10, L'\n');               // удалить разделитель строк
	}

	wcout << L"Целое число: " << i; // целое число без ошибок
	wcout << endl;

	// НЕКОТОРЫЕ ПОЯСНЕНИЯ:

	// Безошибочным в этой программе считаем ввод, при котором не были установлены
	// флаги ошибок, то есть метод wcin.good возвращает значение true.

	// 1) Зачем нужен вызов метода wcin.ignore при безошибочном вводе?
	// Ответ: в данной программе этот вызов можно безболезненно удалить, так как
	// после вызова этого метода поток wcin больше не используется. Этот вызов
	// имел бы смысл, если бы после него программа попыталась бы извлечь из потока wcin
	// еще какие-либо данные. В тексте книги этот пример дан без начала и конца,
	// то есть имеется в виду возможность его применения в программах, в которых
	// дальше может быть еще какое-либо извлечение данных из потока wcin.

	// 2) Зачем нужен вызов метода wcin.ignore при вводе с ошибками?
	// Ответ: например, если пользователь вместо ввода числа 9 цифрой введет его
	// буквами: "девять" и нажмет клавишу Enter, то в буфере окажется строка "девять\n".
	// Команда wcin >> i; при условии, что тип переменной i — integer, может считывать
	// из потока wcin только цифры, поэтому она в случае буфера "девять\n" не считает
	// ничего, а в буфере останется указанная строка "девять\n". Последующие попытки
	// опять считать число с помощью выражения wcin >> i; приведут к такому же
	// финалу. Чтобы всё-таки дать пользователю еще один шанс ввести число, буфер
	// следует очистить. Это и исполняет метод wcin.ignore. В данном случае
	// только после его применения пользователю можно будет дать шанс ввести число
	// еще раз.

	// 3) Хорошо, с методом wcin.ignore понятно, но что означают его параметры: 10 и
	// '\n'? Ответ: эти параметры означают, что метод wcin.ignore должен очистить
	// буфер либо до символа '\n' включительно, либо очистить первые 10 символов,
	// в зависимости от того, какое условие наступит раньше. Например, после команды
	// wcin.ignore(10, L'\n');
	// . буфер "девять\n" (7 символов) станет "" (пустым), т.к. достигнут символ '\n';
	// . буфер "девятнадцать\n" (13 символов) станет "ть\n", т.к. будет стерто 10 символов,
	//   после чего при следующей попытке ввода программа выдаст еще одно сообщение
	//   о неправильном вводе данных и опять применит команду wcin.ignore(10, L'\n');,
	//   после чего буфер, наконец, станет "" (пустым) и программа даст пользователю
	//   шанс ввести число еще раз.

	// 4) Что случится, если в буфере останется символ '\n' перед следующим вводом?
	// Например, при вводе слова "двенадцать" (10 символов) и нажатии на клавишу Enter
	// в буфере окажется значение "двенадцать\n" (11 символов). После срабатывания
	// команды wcin.ignore(10, L'\n'); в буфере останется значение "\n", так как
	// первые 10 символов будут стерты.
	// Ответ: по умолчанию оператор извлечения (<<) игнорирует пробельные символы
	// (пробелы, табуляции, символы перевода строки) из-за включенного флага ios::skipws.
	//
	// НО! мы этот флаг в программе отключили командой wcin.unsetf(ios::skipws);,
	// поэтому
	//
	// в описанном случае перед следующим вводом буфер будет содержать значение "\n".
	// Оператор извлечения (<<) теперь не проигнорирует этот символ перевода строки,
	// программа сочтет это значение буфера ошибочным, выдаст еще одно сообщение
	// о неправильном вводе данных и с помощью команды wcin.ignore(10, L'\n'); сотрет
	// символ "\n" из буфера, после чего пользователю будет дан шанс на новый ввод
	// правильного значения.

	// 5) Что произойдет, если сначала ввести один или несколько пробельных символов
	// (пробелы, табуляции, переводы строк), а затем правильный ввод — число? Например,
	// дважды (или более) нажать на клавишу Enter, а затем ввести число 12.
	//
	// Ответ: так как мы в программе отключили флаг ios::skipws командой
	// wcin.unsetf(ios::skipws);, то теперь будет невозможно нажать при вводе клавишу
	// Enter несколько раз подряд — сразу будет выдано сообщение об ошибке, затем
	// с помощью команды wcin.ignore(10, L'\n'); буфер будет очищен и пользователю
	// вновь будет дать шанс выполнить правильный ввод.
	//
	// Если же сначала ввести один или более раз пробел или табуляцию, будет выдано
	// сообщение об ошибке, так как при выключенном флаге ios::skipws пробельные символы
	// теперь не игнорируются и при их вводе выставляется флаг ошибки, после чего
	// программа точно также очищает буфер с помощью wcin.ignore(10, L'\n'); и дает
	// пользователю новый шанс выполнить правильный ввод.

	return 0;
}