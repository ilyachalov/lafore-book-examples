// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// otype.cpp
// имитирует работу команды type командной строки операционной системы,
// она используется для вывода содержимого файла на экран консоли

// эта команда есть в разных операционных системах, например, в MS-DOS,
// Microsoft Windows и многих других; в некоторых операционных системах
// (Linux, UNIX) команда type выполняет другую работу, а для вывода
// содержимого файла на экран используется команда с другим названием:
// в Linux и UNIX это команда cat

// я добавил в программу две строки для работы с локалью, чтобы можно было
// читать русские буквы из файла в кодировке UTF-8

#include <io.h>      // для функции _setmode
#include <fcntl.h>   // для константы _O_U16TEXT
#include <fstream>   // для файлового ввода/вывода
#include <iostream>
#include <codecvt>   // для работы с фасетом codecvt_utf8 локали
// #include <locale> // не понадобился
using namespace std;
// #include <process.h> // для функции exit не понадобился

int wmain(int argc, wchar_t* argv[])
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ошибок в формат Юникода
	_setmode(_fileno(stderr), _O_U16TEXT);

	// создаем константу, содержащую локаль с нужным фасетом для
	// преобразования символов при чтении из файла в кодировке UTF-8
	const locale utf8_locale = locale(locale(), new codecvt_utf8<wchar_t>());

	if (argc != 2)
	{
		wcerr << L"\nФормат команды: otype имя_файла";
		exit(-1);
		
		// это сообщение об ошибке подразумевает, что исполняемый файл программы
		// называется otype.exe
	}

	wifstream infile;          // создать входной поток
	infile.imbue(utf8_locale); // связываем наш поток с нужной локалью
	infile.open(argv[1]);      // открыть файл
	if (!infile)               // проверить на ошибки
	{
		wcerr << L"\nНе получается открыть " << argv[1];
		exit(-1);
	}

	wchar_t ch;                // символ для считывания
	while (infile.get(ch))     // считать символ (пока не достигнут конец файла)
		wcout << ch;           // отобразить символ

	return 0;
}