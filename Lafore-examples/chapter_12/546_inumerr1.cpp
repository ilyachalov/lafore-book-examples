// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// inumerr1.cpp
// обработка ошибок при вводе чисел

#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT
#include <iostream>
using namespace std;

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	int i; // целое число

	while (true) // бесконечный цикл (выход — с помощью оператора break)
	{
		wcout << L"\nВведите целое число: ";
		wcin >> i;

		// если при вводе не было совершено ошибок
		if (wcin.good())
		{
			wcin.ignore(10, L'\n'); // удалить разделитель строк
			break;                  // выйти из цикла
		}
		
		// при вводе совершены ошибки
		wcin.clear();                         // очистить биты ошибок
		wcout << L"Неправильный ввод данных";
		wcin.ignore(10, L'\n');               // удалить разделитель строк
	}

	wcout << L"Целое число: " << i; // целое число без ошибок
	wcout << endl;

	// НЕКОТОРЫЕ ПОЯСНЕНИЯ:

	// Безошибочным в этой программе считаем ввод, при котором не были установлены
	// флаги ошибок, то есть метод wcin.good возвращает значение true.

	// 1) Зачем нужен вызов метода wcin.ignore при безошибочном вводе?
	// Ответ: в данной программе этот вызов можно безболезненно удалить, так как
	// после вызова этого метода поток wcin больше не используется. Этот вызов
	// имел бы смысл, если бы после него программа попыталась бы извлечь из потока wcin
	// еще какие-либо данные. В тексте книги этот пример дан без начала и конца,
	// то есть имеется в виду возможность его применения в программах, в которых
	// дальше может быть еще какое-либо извлечение данных из потока wcin.

	// 2) Зачем нужен вызов метода wcin.ignore при вводе с ошибками?
	// Ответ: например, если пользователь вместо ввода числа 9 цифрой введет его
	// буквами: "девять" и нажмет клавишу Enter, то в буфере окажется строка "девять\n".
	// Команда wcin >> i; при условии, что тип переменной i — integer, может считывать
	// из потока wcin только цифры, поэтому она в случае буфера "девять\n" не считает
	// ничего, а в буфере останется указанная строка "девять\n". Последующие попытки
	// опять считать число с помощью выражения wcin >> i; приведут к такому же
	// финалу. Чтобы всё-таки дать пользователю еще один шанс ввести число, буфер
	// следует очистить. Это и исполняет метод wcin.ignore. В данном случае
	// только после его применения пользователю можно будет дать шанс ввести число
	// еще раз.

	// 3) Хорошо, с методом wcin.ignore понятно, но что означают его параметры: 10 и
	// '\n'? Ответ: эти параметры означают, что метод wcin.ignore должен очистить
	// буфер либо до символа '\n' включительно, либо очистить первые 10 символов,
	// в зависимости от того, какое условие наступит раньше. Например, после команды
	// wcin.ignore(10, L'\n');
	// . буфер "девять\n" (7 символов) станет "" (пустым), т.к. достигнут символ '\n';
	// . буфер "девятнадцать\n" (13 символов) станет "ть\n", т.к. будет стерто 10 символов,
	//   после чего при следующей попытке ввода программа выдаст еще одно сообщение
	//   о неправильном вводе данных и опять применит команду wcin.ignore(10, L'\n');,
	//   после чего буфер, наконец, станет "" (пустым) и программа даст пользователю
	//   шанс ввести число еще раз.

	// 4) Что случится, если в буфере останется символ '\n' перед следующим вводом?
	// Например, при вводе слова "двенадцать" (10 символов) и нажатии на клавишу Enter
	// в буфере окажется значение "двенадцать\n" (11 символов). После срабатывания
	// команды wcin.ignore(10, L'\n'); в буфере останется значение "\n", так как
	// первые 10 символов будут стерты.
	// Ответ: по умолчанию оператор извлечения (<<) игнорирует пробельные символы
	// (пробелы, табуляции, символы перевода строки) из-за включенного флага ios::skipws.
	// В описанном случае перед вводом буфер будет содержать значение "\n". Если
	// пользователь введет правильное значение (к примеру, число 12) и нажмет клавишу
	// Enter, после этого буфер будет содержать значение "\n12\n". Оператор извлечения (<<)
	// проигнорирует первый символ перевода строки, затем прочтет число 12 в переменную i.
	// Никакой ошибки не произойдет.

	// 5) Что произойдет, если сначала ввести один или несколько пробельных символов
	// (пробелы, табуляции, переводы строк), а затем правильный ввод — число? Например,
	// дважды (или более) нажать на клавишу Enter, а затем ввести число 12.
	// Ответ: к примеру, если дважды нажать при вводе на клавишу Enter, а затем ввести
	// число 12 и еще раз нажать на клавишу Enter, то курсор дважды опустится на строку
	// вниз и число 12 будет принято. В буфере окажется значение "\n\n12\n", но, как уже
	// было подробно описано в ответе на предыдущий вопрос, оператор извлечения (<<)
	// пропустит пробельные символы и успешно считает число 12 в переменную i. Никакой
	// ошибки не произойдет.

	// 6) Что делать, если хочется, чтобы программа выдавала ошибку и на пробельные
	// символы (пробелы, табуляции, переводы строк), введенные пользователем перед
	// числом? Например, при вводе, описанном в предыдущем вопросе.
	// Ответ: для этого можно внести в программу небольшое изменение, см. пример inumerr2.cpp.

	return 0;
}